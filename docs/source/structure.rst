How to write a simple Open Contract
=========

3] how to write the oracle logic

create a new oracle folder with an arbitrary name (we use 'ssn_oracle') and put its folder name into the right place inside interface.json
create an empty oracle.py and put the pip packages you want into requirements.txt
run the pack_wheels.sh script to bundle your oracle. say that it downloads and compresses the packages and takes the hash of the whole folder. the hash it outputs is the oracleID that must be hardcoded into contract.sol (link to the part of step 2] where we did that) instead of 'any', for the final version of the contract. warn that this hash tends to change everytime you rerun stuff, so you only want to hardcode the hash and redeploy the contract.sol when the oracle.py is tested and works.
now provide details for how to write the oracle.py, import any standard python or pip package in requirements.txt, as well as the opencontracts package which only exists in the enclave.
document the functions that are exposed by the enclave object returned from opencontracts.enclave_backend()


Structuring your contract's git repo
-------------

To help illustrate the structure of a simple Open Contract, below is a generated
file-tree for a sample contract. The `contract.sol` file is one that can be treated
as optional, and should be included mainly for transparency so that the contract
source code is viewable to the user. We will explain later on how to implement
this as well. 

::

    contract-repo/
    ├── (README.md)
    ├── (contract.sol)
    ├── interface.json
    └── oracle_folder
        ├── oracle.py
        ├── pip_wheels.tar.gzaa
        └── requirements.txt

The first file that you will need to generate for your contract is the `interface.json`.
In brief, this file will determine the functions and parameters needed to implement
the contract, and is used to allow a user to interact with the rendered Web3 page for
your contract. As an example, here is the `interface.json` from the example `proof-of-id
contract <https://github.com/open-contracts/proof-of-id>`_. 

.. code-block:: json

    {
      "ropsten": {
        "name": "Proof of ID",
        "address": "0xD816921EC3bf96113cDd31B5736B6d9CEb338F4C",
        "abi": [
        {
            "inputs": [],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        { ... } ] } }

At the top layer of the JSON object is the MetaMask network name (in this case, ropsten), 
which defines the network which the contract is deployed in. In order to extend your
contract to other networks, such as mainnet, you will need to add another field to
this dictionary with the correct name for that network.
Below this are some fields that specify the name, address, and contract ABI (or Application Binary Interface) fields, which locate the generated bytecode for the contract so it
can be properly triggered in the Ethereum block chain. The ABI yields a list of
functions that are exposed by the contract, including information about their
respective inputs, outputs, and additional fields such as "description"
which can help users in understanding and using the contract.

When editing the contract Solidity code in the `Remix IDE <https://remix.ethereum.org/>`_, 
you will have an option to automatically generate the contract's ABI. This can
be done once, having written a contract in Remix, you go to compile the contract, and
copy the contract's ABI by clicking on the copy-paste icon below **Compilation Details**.
This ABI will contain a list of all method signatures used in the contract, each represented
as a JSON object with properties such as inputs (optional), outputs, stateMutability, type, description.
You will add the ABI to the `interface.json` under the "abi" field (as shown in the example above).
After adding this to the json (under the "abi" field shown above), you will also need
to deploy the contract and get its contract address. To do this, open the **Deploy and Run
Transactions** tab (bottom icon in Remix), and hit Deploy, after which you can copy the
contract address below **Deployed Contracts**. When testing contracts, make sure to use
the Ropsten Network and not the mainnet.

After adding the ABI and contract address, you will need to add two more properties to the `interface.json`. 
First, for readability, go through the functions objects in the ABI list and include a "description" property to each describing what the function does. 
Additionally, if your function needs to use an oracle, you will have to specify the path of an "Oracle Folder" under which the `oracle.py` containing the oracle logic is kept. 
Do this by adding the directory name to the function dict as a JSON field titled "oracleFolder". For an example, see the `interface.json from the Proof-of-id <https://github.com/open-contracts/proof-of-id/blob/main/interface.json#L33>`_, which uses the oracleFolder `ssn_oracle`.

In addition to the `oracle.py`, the oracle folder may also contain a `requirements.txt` file, which is used to install any required pip packages to a `pip_wheels.tar.gzaa` archive for the oracle. This allows for the use of 3rd party APIs or libraries that may be required for the oracle logic.

Finally, including the original `contract.sol` file in the repository is an optional step to help make the contract visible in the generated Web3 Open Contract site. However, this has no
effect on the actual contract that is deployed on the network, and should not
be trusted as a source of truth in terms of the contents of an actual contract.

Writing and deploying smart contracts with oracle logic
-------------
2] how to write and deploy smart contracts that require a specific oracle logic

In order to create an Open Contract, you must first write a piece of solidity code that
defines the Ethereum smart contract logic. For a more comprehensive tutorial of
Ethereum smart contacts, we recommend starting `here <https://docs.soliditylang.org/en/v0.7.4/solidity-by-example.html>`_.

In this tutorial, we will go through writing the `Proof-of-id contract <https://github.com/open-contracts/proof-of-id/blob/main/contract.sol>`_ step-by-step.
Writing this contract can be broken into two main steps: writing the `contract.sol` and writing the oracle logic.

**Writing contract.sol**
First we'll cover the template contract that you will be using. Navigate to 
`Remix IDE <https://remix.ethereum.org/>`_ in your browser, and add the file
`contract.sol` under the `contracts/artifacts/` directory.

Like all other contracts, it will be importing the `OpenContractRopsten.sol` defined below:

.. code-block:: solidity

    contract OpenContract {
        address private hub = 0xACf12733cBa963201Fdd1757b4D7A062AD096dB1;
        mapping(bytes8 => bytes32) private allowedID;

        function setOracle(bytes32 oracleID, bytes8 selector) internal {
            allowedID[selector] = oracleID;
        }

        modifier checkOracle(bytes32 oracleID, bytes4 selector) {
            require(msg.sender == hub, "Can only be called via Open Contracts Hub.");
            if (allowedID[selector] != "any") {
                require(oracleID == allowedID[selector], "Incorrect OracleID.");
            }
            _;
        }
    }

This contract defines a few simple properties: a hub (used to ensure that the
contract is being called from a trusted "hub"), and a map of allowed IDs, called an **oracleID**. **oracleIDs**
are a unique hash of an oracle node that is allowed to execute a given contract, and is mapped to by a **selector**.
The **selector** is a function name that the oracle will call to resolve the contract.
When the constructor of a contract inheriting `OpenContract` is called, it will use the `setOracle` function to assign an oracleID to the contract. However, during development, the oracleID `any` is used to allow all oracle hashes. Next, the function modifier `checkOracle` is used as a method to check that an oracleID is valid before proceeding to execute the contract's oracle function. You will see an example of this next when defining the proof-of-id contract's `createID` method, which uses
the checkOracle function.

The proof-of-id contract uses the secure computation environment of the Oracle nodes to
allow users to generate a unique encrypted ID that is verified using an external form of verification. A user proves their identity to the oracle by their SSN account.
First, let us define the Proof-of-id OpenContract in contract.sol in Remix under `contracts/artifacts/contract.sol`: 

.. code-block:: solidity

    pragma solidity ^0.8.0;
    import "https://github.com/open-contracts/protocol/blob/main/solidity_contracts/OpenContractRopsten.sol";


    contract ProofOfID is OpenContract {

        mapping(bytes32 => address) private _account;
        mapping(address => bytes32) private _ID;

        constructor() {
            setOracle("any", this.createID.selector);  // developer mode, allows any oracle for 'createID'
        }
        ....
    }

In the first half of the contract, we define the solidity syntax version, followed by
importing the OpenContract.sol base contract implementation which we defined above.
Next, the contract `ProofOfID` is defined inheriting the OpenContract structure
(see `link <https://www.tutorialspoint.com/solidity/solidity_inheritance.htm>`_ for 
explanation of Solidity inheritance).
The two mappings _account and _ID form a bi-directional mapping between ETH
accounts addresses and the generated unique IDs for a user, which is acquired
once they have proven their identity to the oracle by securely verifying their last
4-digits of their SSN.
As mentioned above, in the constructor, the `setOracle` method currently uses
"any" for the oracleID to allow the createID method to be called on any oracle 
node for development purposes.

Once the mappings and constructor are defined, functions used to get IDs and accounts
using these mappings are specified, followed by the createID method, which
is called by the oracle when the SSN proof has been verified.

.. code-block:: solidity

    contract ProofOfID is OpenContract{
    ....
        function getID(address account) public view returns(bytes32) {
            require(_ID[account] != bytes32(0), "Account doesn't have an ID.");
            return _ID[account];
        }

        function getAccount(bytes32 ID) public view returns(address) {
            require(_account[ID] != address(0), "ID was never created.");
            return _account[ID];
        }

        function createID(bytes32 oracleID, address user, bytes32 ID) 
        public checkOracle(oracleID, this.createID.selector) {
            _ID[_account[ID]] = bytes32(0);
            _account[ID] = user;
            _ID[user] = ID;
        }
    }

Note that for any function to modify the _account and _ID mappings, they must
first call the OpenContract's checkOracle function modifier which confirms that the
request is being made by a valid oracleID. It is important to note that 
the first argument of any method using the checkOracle function must always
have oracleID as it's first argument, so it can properly interact with the
function modifier. After this check is passed, the user is able to map their address to their generated user ID, completing the proof-of-ID contract.

Implementing the oracle logic and include it in your repo
-------------

