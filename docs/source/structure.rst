How to write a simple Open Contract
====================================

Structuring your contract's git repo
------------------------------------

To help illustrate the structure of a simple Open Contract, below we walkthrough
the generated file-tree for a sample contract. The ``contract.sol`` file is one that can be treated
as optional, and should be included mainly for transparency so that the contract
source code is viewable to the user. We will explain later on how to implement
this as well.

::

    contract-repo/
    ├── (README.md)
    ├── (contract.sol)
    ├── interface.json
    └── [oracle_folder]
        ├── oracle.py
        ├── pip_wheels.tar.gzaa
        └── requirements.txt

The first file that you will need to generate for your contract is the ``interface.json``.
In brief, this file will determine the functions and parameters needed to implement
the contract, and is used to allow a user to interact with the rendered Web3 page for
your contract. As an example, here is the ``interface.json`` from the example `proof-of-id
contract <https://github.com/open-contracts/proof-of-id>`_. 

.. code-block:: json

    {
     "name": "Proof of ID",
     "address": {
       "ropsten": "0xA520fc19E71edDb52134eD5B146c2f5887CBfB13"
     },
     "descriptions": {
       "contract": "This is the contract description",
       "createID": "This is the description for the createID function"
     },
     "abi": [{...}]
     }

At the top level of the interface JSON object is the MetaMask network name under address (in this case, ropsten) mapped to the address of the published contract, which we will discuss how to
get below. In order to extend your
contract to other networks, such as mainnet, you will need to add another field to this dictionary with the correct name for that network.
Below this are fields that specify the the contract (using the "contract" field) descriptions for functions defined by the contract, and the contract ABI (or Application Binary Interface). The ABI is a list of functions that are exposed by the contract, including information about their respective inputs and outputs.
When editing the contract Solidity code in the `Remix IDE <https://remix.ethereum.org/>`_, 
you will have an option to automatically generate and copy the contract's ABI. You can 
copy the contract's ABI by clicking on the copy-paste icon below **Compilation Details** once you have 
compiled the contract having written it in Remix.
This will return a list of all method signatures used in the contract, each represented
as a JSON object with properties such as inputs (optional), outputs, stateMutability, type, description.
Add this ABI to the JSON under the "abi" field (as shown in the example above), which is
used to help load the contract on the OpenContracts dapp page.

After adding the ABI to the JSON, you will also need to deploy the contract to get its contract address.
To do this, open the **Deploy and Run Transactions** tab (bottom icon in Remix), and hit Deploy, after which you can copy the
contract address below **Deployed Contracts**. When testing out your contracts, make sure to use
the Ropsten Network and not the mainnet.

After adding the ABI and contract address the JSON is complete, and is almost ready
to create a visual explorer for your contract using the `OpenContracts Dapp frontend <https://dapp.opencontracts.io>`_.
If your contract will use an oracle to parse and verify internet data that is generated by a user
(which will involve connecting to an `AWS Secure Enclave <https://aws.amazon.com/ec2/nitro/nitro-enclaves/>`_), an additional directory
(named the same as the oracle function in the contract) will need to be added to the git repo. This directory
should contain a file `oracle.py`, which contains the code to parse user data and attest to the OpenContracts backend
that the submitted user data is what was expected to trigger the contract function. It will also
contain the `requirements.txt` file, which will contain Python packages that the oracle script can access.

Once having created an oracle folder for each oracle function (usually there isn't more than one), you
can run the **oracle pack** script at the root of the repo. This creates set of pip wheels that ensure
that the enclave running the oracle script has the necessary python dependencies, in addition to
generating a oracleHash which is used to register the repo with the OracleHub in its current state with the pip dependencies,
so that the contract can trust the code that triggers the contract (for more details, visit `protocol.md <https://www.opencontracts.io/#/protocol>`_). 
To run the pack script, simply run

.. code-block:: console

  $ curl -Ls pack.opencontracts.io | sh

in the command line. Doing this is allows for the use of 3rd party APIs or libraries that may be required for the oracle logic, as
well as the verification by the contract that the oracle.py code is 

Finally, including the original `contract.sol` file in the repository is an optional step to help make the contract visible in the generated Web3 Open Contract site. However, this has no
effect on the actual contract that is deployed on the network, and should not be trusted as the source of truth when viewing the contents of an actual contract.

.. _writing-deploying:

Writing and deploying smart contracts with oracle logic
-------------------------------------------------------
In order to create an Open Contract, you must first write a piece of solidity code that
defines the Ethereum smart contract logic. For a more comprehensive tutorial of
Ethereum smart contacts, we recommend starting `here <https://docs.soliditylang.org/en/v0.7.4/solidity-by-example.html>`_.

In this tutorial, we will go through writing the `Proof-of-id contract <https://github.com/open-contracts/proof-of-id/blob/main/contract.sol>`_ step-by-step.
Writing this contract can be broken into two main steps: writing the ``contract.sol`` and writing the oracle logic.

**Writing contract.sol**
First we'll cover the template contract that you will be using. Navigate to 
`Remix IDE <https://remix.ethereum.org/>`_ in your browser, and add the file
``contract.sol`` under the ``contracts/`` directory.

Like all other contracts, it will be importing the `OpenContractRopsten.sol <https://github.com/open-contracts/ethereum-protocol/blob/main/solidity_contracts/OpenContractRopsten.sol>`_ defined below:

.. code-block:: solidity

    contract OpenContract {
        OpenContractsHub private hub = OpenContractsHub(0x059dE2588d076B67901b07A81239286076eC7b89);

        // this call tells the Hub which oracleID is allowed for a given contract function
        function setOracleHash(bytes4 selector, bytes32 oracleHash) internal {
            hub.setOracleHash(selector, oracleHash);
        }

        modifier requiresOracle {
            // the Hub uses the Verifier to ensure that the calldata came from the right oracleID
            require(msg.sender == address(hub), "Can only be called via Open Contracts Hub.");
            _;
        }
    }


This contract defines a few simple properties: a hub (used to ensure that the
contract is being called from a trusted "hub"), and a map of allowed IDs, called an **oracleHash**. **oracleHashes**
are a unique hash of an oracle node that is allowed to execute a given contract, and is mapped to by a **selector**.
The **selector** is a function name that the oracle will call to resolve the contract.
When the constructor of a contract inheriting ``OpenContract`` is called, it will use the ``setOracle`` function to assign an oracleID to the contract. However, during development, the oracleID ``any`` is used to allow all oracle hashes. Next, the function modifier ``requiresOracle`` is used as a method to check that an oracleID is valid before proceeding to execute the contract's oracle function. You will see an example of this next when defining the proof-of-id contract's `createID <https://github.com/open-contracts/proof-of-id/blob/main/contract.sol#L23>`_ method, which uses the requiresOracle function.

The Proof-of-Id contract uses the secure enclaves to allow users to generate a unique encrypted ID that is verified using an external form of verification. A user proves their identity to the oracle by their SSN account. First, let us define the Proof-of-Id OpenContract in contract.sol in Remix under `contracts/contract.sol`: 

.. code-block:: solidity

    pragma solidity ^0.8.0;
    import "https://github.com/open-contracts/protocol/blob/main/solidity_contracts/OpenContractRopsten.sol";

    contract ProofOfID is OpenContract {

        mapping(bytes32 => address) private _account;
        mapping(address => bytes32) private _ID;

        constructor() {
            setOracle("any", this.createID.selector);  // developer mode, allows any oracle for 'createID'
        }
        ....
    }

In the first half of the contract, we define the solidity syntax version, followed by
importing the OpenContract.sol base contract implementation which we defined above.
Next, the contract ``ProofOfID`` is defined inheriting the OpenContract structure
(see `link <https://www.tutorialspoint.com/solidity/solidity_inheritance.htm>`_ for 
explanation of Solidity inheritance).
The two mappings _account and _ID form a bi-directional mapping between ETH
accounts addresses and the generated unique IDs for a user, which is acquired
once they have proven their identity to the oracle by securely verifying their last
4-digits of their SSN.
As mentioned above, in the constructor, the ``setOracle`` method currently uses
"any" for the oracleHash to allow the createID method to be called on any oracle 
node for development purposes.

Once the mappings and constructor are defined, functions used to get IDs and accounts
using these mappings are specified, followed by the createID method, which
is called by the oracle when the SSN proof has been verified.

.. code-block:: solidity

    contract ProofOfID is OpenContract{
    ....
        function getID(address account) public view returns(bytes32) {
            require(_ID[account] != bytes32(0), "Account doesn't have an ID.");
            return _ID[account];
        }

        function getAccount(bytes32 ID) public view returns(address) {
            require(_account[ID] != address(0), "ID was never created.");
            return _account[ID];
        }

        function createID(address user, bytes32 ID) public requiresOracle { 
            _ID[_account[ID]] = bytes32(0);
            _account[ID] = user;
            _ID[user] = ID;
        }
    }

Note that for any function to modify the _account and _ID mappings, they must
first call the OpenContract's checkOracle function modifier which confirms that the
request is being made by a valid oracleHash. It is important to note that
the first argument of any method using the checkOracle function must always
have oracleHash as it's first argument, so it can properly interact with the
function modifier. After this check is passed, the user is able to map their address
to their generated user ID, completing the Proof-of-ID contract. This will result
in their account paying out to the correct provider wallet.

Implementing the oracle logic and include it in your repo
---------------------------------------------------------

Last but not least, the `oracle.py <https://github.com/open-contracts/proof-of-id/blob/main/createID/oracle.py>`_ script is what enables the key contribution
of the OpenContracts platform: the ability to connect smart contract transactions
to events which are verified by the oracle. This script will parse an html
that gets generated by a user once they have opened an interactive session to
log into an account and access data that only they can provide.
To use this platform, the script imports the opencontracts module from the
`enclave-protocol <https://github.com/open-contracts/enclave-protocol/blob/main/oracle_enclave/user/opencontracts.py#L83>`_,
and some additional modules (bs4 and re) for parsing purposes.

Next, in every oracle script, an ``opencontracts.enclave_backend()`` context manager
is opened to give the script access to the enclave user API, which defines the following
functions:

* ``enclave.print()``: Prints something to the user console (which is displayed on the opencontracts.io contract frontend)
* ``enclave.interactive_session()``: Creates a secure browsing session inside the enclave for the user to navigate to a desired url containing the data to be parsed
* ``enclave.keccak()``: Wrapper to call the ``eth_utils.keccak`` function to generate a hash
* ``enclave.expect_delay()``: Function to create a loading bar in the front-end
* ``enclave.user()``: Returns the user ETH address after being verified by the enclave (by checking a signed random string)
* ``enclave.submit()``: Calls the oracle function in the smart contract once the enclave has verified the parsed data

.. code-block:: python

    import opencontracts
    from bs4 import BeautifulSoup
    import re

    with opencontracts.enclave_backend() as enclave:
      enclave.print(f'Proof of Identity started running in enclave!')

      def parser(url, html):
        target_url = "https://secure.ssa.gov/myssa/myprofile-ui/main"
        assert url == target_url, f"You clicked 'Submit' on '{url}', but should do so on '{target_url}'."
        strings = list(BeautifulSoup(html).strings)
        for key, value in zip(strings[:-1],strings[1:]):
          if key.startswith("Name:"): name = value.strip()
          if key.startswith("SSN:"): last4ssn = int(re.findall('[0-9]{4}', value.strip())[0])
          if key.startswith("Date of Birth:"): bday = value.strip()
        return name, bday, last4ssn


In this first section of the code, the parser method is defined to specify how it
will extract the SSN, birthday, and name of the users page once they have signed 
into the SSA government portal through the interactive session.

.. code-block:: python

   # ... imports
   with opencontracts.enclave_backend() as enclave:
      # ... parser
      name, bday, last4ssn = enclave.interactive_session(url='https://secure.ssa.gov/RIL/', parser=parser,
                                                         instructions="Login and visit your SSN account page.")

      # we divide all 10000 possible last4ssn into 32 random buckets, by using only the last 5=log2(32) bits
      # so last4ssn isn't revealed even if ssn_bucket can be reverse-engineered from ID
      ssn_bucket = int(enclave.keccak(last4ssn, types=('uint256',))[-1]) % 32
      ID = enclave.keccak(name, bday, ssn_bucket, types=('string', 'string', 'uint8'))

      # publishing your SSN reveals that last4ssn was one of the following possibilites:
      possibilities = list()
      enclave.expect_delay(8, "Computing ID...")
      for possibility in range(10000):
        bucket = int(enclave.keccak(possibility, types=("uint256",))[-1]) % 32
        if bucket == ssn_bucket: possibilities.append(str(possibility).zfill(4))
      n = len(possibilities)

      warning = f'Computed your ID: {"0x" + ID.hex()}, which may reveal your name ({name}), birthday ({bday})'
      enclave.print(warning + f' and that your last 4 SSN digits are one of the following {n} possibilites: {possibilities}')

      enclave.submit(enclave.user(), ID, types=('address', 'bytes32',), function_name='createID')

In the latter section, the enclave ``interactive_session`` stores the result from the parser 
as variables, and then performs a randomizing step which cryptographically obscures
the last 4 SSN from any non-trusted parties (using ``keccak``). Finally, it 
submits the result to the ``createID`` function, which stores the mapping from the
user's ETH account to their newly-generated unique SSN hash.

Congrats! You have completed the walkthrough of the first Open Contract!
Now you can try joining the `Discord <https://discord.gg/5X74aw2q>`_ and 
`Reddit <https://reddit.com/r/open_contracts>`_ communities to connect with
developers and learn more, buy our token on `Uniswap <https://app.uniswap.org/#/swap?outputCurrency=0xa2d9519A8692De6E47fb9aFCECd67737c288737F&chain=mainnet>`_.
