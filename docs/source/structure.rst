How to write a simple Open Contract
=========

3] how to write the oracle logic

create a new oracle folder with an arbitrary name (we use 'ssn_oracle') and put its folder name into the right place inside interface.json
create an empty oracle.py and put the pip packages you want into requirements.txt
run the pack_wheels.sh script to bundle your oracle. say that it downloads and compresses the packages and takes the hash of the whole folder. the hash it outputs is the oracleID that must be hardcoded into contract.sol (link to the part of step 2] where we did that) instead of 'any', for the final version of the contract. warn that this hash tends to change everytime you rerun stuff, so you only want to hardcode the hash and redeploy the contract.sol when the oracle.py is tested and works.
now provide details for how to write the oracle.py, import any standard python or pip package in requirements.txt, as well as the opencontracts package which only exists in the enclave.
document the functions that are exposed by the enclave object returned from opencontracts.enclave_backend()


Structuring your contract's git repo
-------------

To help illustrate the structure of a simple Open Contract, below is a generated
file-tree for a sample contract. The `contract.sol` file is one that can be treated
as optional, and should be included mainly for transparency so that the contract
source code is viewable to the user. We will explain later on how to implement
this as well. 

::

    contract-repo/
    ├── (README.md)
    ├── (contract.sol)
    ├── interface.json
    └── oracle_folder
        ├── oracle.py
        ├── pip_wheels.tar.gzaa
        └── requirements.txt

The first file that you will need to generate for your contract is the `interface.json`.
In brief, this file will determine the functions and parameters needed to implement
the contract, and is used to allow a user to interact with the rendered Web3 page for
your contract. As an example, here is the `interface.json` from the example `proof-of-id
contract <https://github.com/open-contracts/proof-of-id>`_. 

.. code-block:: json

    {
      "ropsten": {
        "name": "Proof of ID",
        "address": "0xD816921EC3bf96113cDd31B5736B6d9CEb338F4C",
        "abi": [
        {
            "inputs": [],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        { ... } ] } }

At the top layer of the JSON object is the MetaMask network name (in this case, ropsten), 
which defines the network which the contract is deployed in. In order to extend your
contract to other networks, such as mainnet, you will need to add another field to
this dictionary with the correct name for that network.
Below this are some fields that specify the name, address, and contract ABI (or Application Binary Interface) fields, which locate the generated bytecode for the contract so it
can be properly triggered in the Ethereum block chain. The ABI yields a list of
functions that are exposed by the contract, including information about their
respective inputs, outputs, and additional fields such as "description"
which can help users in understanding and using the contract.

When editing the contract Solidity code in the `Remix IDE <https://remix.ethereum.org/>`_, 
you will have an option to automatically generate the contract's ABI. This can
be done once, having written a contract in Remix, you go to compile the contract, and
copy the contract's ABI by clicking on the copy-paste icon below **Compilation Details**.
This ABI will contain a list of all method signatures used in the contract, each represented
as a JSON object with properties such as inputs (optional), outputs, stateMutability, type, description.
You will add the ABI to the `interface.json` under the "abi" field (as shown in the example above).
After adding this to the json (under the "abi" field shown above), you will also need
to deploy the contract and get its contract address. To do this, open the **Deploy and Run
Transactions** tab (bottom icon in Remix), and hit Deploy, after which you can copy the
contract address below **Deployed Contracts**. When testing contracts, make sure to use
the Ropsten Network and not the mainnet.

After adding the ABI and contract address, you will need to add two more properties to the `interface.json`. 
First, for readability, go through the functions objects in the ABI list and include a "description" property to each describing what the function does. 
Additionally, if your function needs to use an oracle, you will have to specify the path of an "Oracle Folder" under which the `oracle.py` containing the oracle logic is kept. 
Do this by adding the directory name to the function dict as a JSON field titled "oracleFolder". For an example, see the `interface.json from the Proof-of-id <https://github.com/open-contracts/proof-of-id/blob/main/interface.json#L33>`_, which uses the oracleFolder `ssn_oracle`.

In addition to the `oracle.py`, the oracle folder may also contain a `requirements.txt` file, which is used to install any required pip packages to a `pip_wheels.tar.gzaa` archive for the oracle. This allows for the use of 3rd party APIs or libraries that may be required for the oracle logic.

Finally, including the original `contract.sol` file in the repository is an optional step to help make the contract visible in the generated Web3 Open Contract site. However, this has no
effect on the actual contract that is deployed on the network, and should not
be trusted as a source of truth in terms of the contents of an actual contract.

Writing and deploying smart contracts that require specific oracle logic
-------------
2] how to write and deploy smart contracts that require a specific oracle logic

In order to create an Open Contract, you must first write a piece of solidity code that
defines the Ethereum smart contract logic. For a more comprehensive tutorial of
Ethereum smart contacts, we recommend starting `here <https://docs.soliditylang.org/en/v0.7.4/solidity-by-example.html>`_.

Writing this contract can be broken into two main steps,
Use https://github.com/open-contracts/proof-of-id/blob/main/contract.sol as a simple example for a contract that requires an oracle logic (fiat swap is too complex. but we'll keep it as a tutorial for a more 'advanced' contract)
keep the oracleID at 'any' (which allows all hashes), but put a warning that this eventually needs to be replaced by the hash that we compute in Step 3.
walk people through how to deploy it in remix, show them were to get address and abi to put it into interface.json
now you can already access the contract on our website! but you won't be able to call the oracle function yet.

Implementing the oracle logic and include it in your repo
-------------

